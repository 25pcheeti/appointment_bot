Project Structure

This document explains each top‑level file and directory in the 
appointment_bot project and how each component fits into the overall data 
pipeline.

📄 LICENSE

What goes here: The open‑source license text (MIT).

Pipeline role: Declares usage rights and contribution terms.

Why separate: Keeps legal details distinct from code.

📄 Makefile

What goes here: Command shortcuts (e.g., make data, make train, make 
test).

Pipeline role: Automates common tasks and enforces consistent workflows.

Why separate: Centralizes task orchestration outside scripts.

📄 README.md

What goes here: Project overview, quickstart, and basic instructions.

Pipeline role: Entry point for users and contributors to understand and 
run the project.

Why separate: Provides a high‑level summary without diving into code.

📄 pyproject.toml

What goes here: Build system requirements and package metadata (PEP 
517/518).

Pipeline role: Defines editable install (pip install -e .) and build 
dependencies.

Why separate: Keeps build configuration distinct from source logic.

📄 environment.yml / requirements.txt

What goes here: Conda environment (environment.yml) and pip dependencies 
(requirements.txt).

Pipeline role: Ensures reproducible development and deployment 
environments.

Why separate: Explicitly version and manage package requirements.

📄 setup.py

What goes here: Legacy package metadata and installation hooks.

Pipeline role: Enables pip install and packaging for distribution.

Why separate: Maintains compatibility with packaging tools.

📁 appointment_bot.egg-info

What goes here: Metadata generated by editable installs (auto‑created).

Pipeline role: Supports package installation and metadata storage.

Why separate: Managed by tooling, not manually edited.

📁 data/

Subdirectories:

raw/ (original downloads)

interim/ (partially processed data)

processed/ (cleaned and ready for modeling)

external/ (third‑party or reference datasets)

Pipeline role: Tracks data through acquisition, cleaning, and processing 
stages.

Why separate: Prevents accidental overwrites and clarifies provenance.

📁 notebooks/

What goes here: Jupyter notebooks for EDA and prototyping.

Pipeline role: Exploratory data analysis and visualization drafts.

Why separate: Keeps exploratory work distinct from production code.

📁 appointment_bot/ (Python package)

What goes here: Core library code:

config.py (paths & logger setup)

dataset.py, features.py, plots.py

subpackages: features/, modeling/

Pipeline role: Encapsulates reusable functions and classes.

Why separate: Allows importable modules and unit testing.

📁 src/

What goes here: Standalone scripts and CLI entrypoints:

src/data/download_dataset.py

src/models/train_model.py

Pipeline role: Wrappers to run end‑to‑end pipeline steps.

Why separate: Keeps “scripts” distinct from library code.

📁 models/

What goes here: Saved model artifacts (e.g., logreg.pkl).

Pipeline role: Stores trained models for inference.

Why separate: Separates output artifacts from source code.

📁 reports/

Subdirectory: figures/ (plots, ROC curves, etc.)

Pipeline role: Houses generated visualizations for documentation.

Why separate: Keeps static outputs out of source and code.

📁 docs/

What goes here: Project documentation and write‑ups:

This file (01_structure.md)

Reflection and architecture docs.

Pipeline role: Stores design rationale and user/developer guides.

Why separate: Keeps prose and diagrams outside code files.

📁 references/

What goes here: Supplementary materials (papers, links, etc.).

Pipeline role: Provides background and citations.

Why separate: Keeps source code uncluttered by extras.

📁 tests/

What goes here: Unit tests for each module (using pytest).

Pipeline role: Validates correctness of features and pipeline.

Why separate: Isolates test code, ensuring clear test discovery.
